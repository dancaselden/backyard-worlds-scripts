"""
Create a new CSV joining brown dwarfs and subjects
"""
import collections
import byw.formats.simbadascii as sba
import byw.formats.subject as subj
import numpy as np
import bisect

import byw.formats.bdsubject as bdsbj

BDBox = collections.namedtuple("BDBox","entry,raleft,raright,debot,detop")

# Handle rolling over boundaries
def ra_(ra):
    if 0 > ra or ra > 360:
        return ra%360.0
    return ra

# ahhh. crap.
#def de_(de):
#    if de > 90:
#        return de-180
#    if de < -90:
#        return de+180
#    return de

def point_in_bb(bd,s):
    # Test if subj between raleft and raright
    sra = float(s.ra)
    if bd.raleft < bd.raright:
        # RA spans 0
        if not ((bd.raleft >= sra and
                 sra >= 0) or
                (360 >= sra and
                 sra >= bd.raright)):
            return False
    else:
        if not (bd.raleft >= sra and
                sra >= bd.raright):
            return False
    sde = float(s.de)
    # Test if subj between debot and detop
    if (bd.debot < -90 or bd.debot > 90 or
        bd.detop < -90 or bd.detop > 90):
        # DE spans 0
        raise Exception("Bounding box covers a pole. Do I look like an astronomer?\n%s\n%s"%(bd,s))
    else:
        if not (bd.debot <= sde and
                sde <= bd.detop):
            return False
    return True

class radecoll(list):
    def __init__(self,*args,**kwargs):
        tmp = list(*args,**kwargs)
        for o in tmp:
            self.add(o)
    def add(self,o):
        # Wrap w/ bottom de
        bisect.insort(self,(o.detop,o))
    def in_objs(self,o):
        objs = []
        o = (float(o.de),o)
        if o[0] < -90:
            raise Exception("Bounding box covers a pole. Do I look like an astronomer?\n%s\n%s"%(bd,s))
        # Find left-most position
        idx = bisect.bisect_left(self,o)
        for i in xrange(idx,len(self)):
            bd = self[i]
            if o[0] < bd[1].debot:
                break
            if point_in_bb(bd[1],o[1]):
                objs.append(bdsbj.BDSubject(o[1].subject_id,
                                            bd[1].entry.ra,
                                            bd[1].entry.de))
        return objs
            

def main():
    import argparse
    ap = argparse.ArgumentParser(description="Create a new CSV by joining"+
                                 " a simbadascii format table of objects "+
                                 "and a CSV of subjects")
    ap.add_argument("object_table",
                    help="SimbadEntry CSV format, such as generated by bdextract")
    ap.add_argument("subjects",
                    help="Subjects CSV format, such as generated by subjectextract")
    ap.add_argument("outfile",
                    help="Where to write output CSV")
    args = ap.parse_args()
    # Parse BDs into memory
    # Maybe try KD tree if n*m is too slow
    pic_angle = 0.0975
    bds = radecoll()
    # Could do KDtree, but the RA-wrapping would need thinking.
    # I'd love to use astropy's kdtree, but skycoords are
    # extremely slow. unfortunately, so slow that the algorithmic
    # improvement from a kdtree probably wouldn't overcome the linear slowdown
    # - Instead, sort by declination. 
    print "Parsing BDs into memory and building bounding boxes"
    for e in sba.SimbadEntryReader(args.object_table):
        # Get bottom-left point, adjusting RA
        ra = float(e.ra)
        de = float(e.de)
        raofs = (pic_angle/np.cos(np.deg2rad(de)))
        # Extract ra,dec from bottom-left and top-right, and get rid
        #   of astropy coordinates, to make a fast bounding box
        bds.add(BDBox(e,
                      ra_(ra+raofs),ra_(ra-raofs),
                      de-pic_angle,de+pic_angle))
    print "Done"
    rdr = subj.SubjectReader(args.subjects)
    of = open(args.outfile,'wb')
    of.write(bdsbj.BDSubjectHeader)
    of.write('\n')
    i = 1
    while True:
        if i % 1000 == 0:
            print i
        i += 1
        s = rdr.readline()
        if not s: break
        for obj in bds.in_objs(s):
            of.write(','.join([str(k) for k in obj]))
            of.write('\n')
            
        
if __name__ == "__main__":
    main()
    
