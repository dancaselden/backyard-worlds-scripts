import byw.formats.bdsubjannot as bdsa
import byw.formats.bdsubject as bdsj
import byw.formats.annotation as annot
import byw.formats.classification as clasi

def main():
    import argparse
    ap = argparse.ArgumentParser(description="Create a new CSV by joining"+
                                 " a simbadascii format table of objects "+
                                 "and a CSV of subjects")
    ap.add_argument("bdsubject",
                    help="BD Subject Join format, such as generated by bdsubjectjoin")
    ap.add_argument("classifications",
                    help="Classifications CSV format, such as generated by annotationextract")
    ap.add_argument("bdsubjannot",
                    help="BD-Subject-Annotation CSV format, such as generated by bdsubjannotjoin")
    args = ap.parse_args()
    print "Loading BDSubjects %s"%args.bdsubject
    # Parse bdsubjects into memory first
    # Key on both bd coords and subject id
    bd_coords = {}
    sid_to_bds = {}
    clasis = {}
    rdr = bdsj.BDSubjectReader(args.bdsubject)
    while True:
        subj = rdr.readline()
        if not subj: break
        coord = (subj.ra,subj.de) # Use verbatim string for rear of rounding
        sid = int(subj.subject_id)
        if not coord in bd_coords:
            bd_coords[coord] = {} # classifications
        # Make ref so classifications can look up by subj id
        if not sid in sid_to_bds:
            sid_to_bds[sid] = []
        sid_to_bds[sid].append(coord)

    print "Loading classifications %s"%args.classifications
    # Parse classifications
    rdr = clasi.ClassificationReader(args.classifications)
    while True:
        clsi = rdr.readline()
        if not clsi: break
        clasis[int(clsi.classification_id)] = clsi
        sid = int(clsi.subject_ids)
        if sid not in sid_to_bds:
            # No BDs in this subject
            continue
        # For all BDs in this subject
        for coord in sid_to_bds[sid]:
            # Store that a classification exists for this BD
            bd_coords[coord][int(clsi.classification_id)] = 0

    print "Loading BD Subject Annotations %s"%args.bdsubjannot
    # Parse annotations
    rdr = bdsa.BDSubjAnnotReader(args.bdsubjannot)
    while True:
        bdsa_ = rdr.readline()
        if not bdsa_: break
        # > 30arcsecs, considered a miss
        coord = (bdsa_.bd_ra,bdsa_.bd_de)
        # A click happened on the subj somewhere. Mark w/ #1
        if bd_coords[coord][int(bdsa_.classification_id)] < 1:
            bd_coords[coord][int(bdsa_.classification_id)] = 1
        if float(bdsa_.separation) > 0.00833333*2: continue
        # It was a good click. Mark w/ #2
        if bd_coords[coord][int(bdsa_.classification_id)] < 2:
            bd_coords[coord][int(bdsa_.classification_id)] = 2

    # Write stats
    print "RA,DEC,Total Classifications,Classifications Without Annotations,Classifications with Positive Annotations"
    users = {}
    for coord in bd_coords:
        tot_cls = 0
        non_cls = 0
        pos_cls = 0
        for cls in bd_coords[coord]:
            real_cls = clasis[cls]
            if not real_cls.user_name in users:
                users[real_cls.user_name] = [[],[]]
            tot_cls += 1
            users[real_cls.user_name][0].append(cls)
            if bd_coords[coord][cls] == 1:
                users[real_cls.user_name][1].append(1)
                non_cls += 1
            elif bd_coords[coord][cls] == 2:
                users[real_cls.user_name][1].append(2)
                pos_cls += 1
        print ','.join([str(k) for k in (coord[0],coord[1],tot_cls,non_cls,pos_cls)])
    srtuser = []
    for user in users:
        pos = 0; neg = 0
        for c in users[user][1]:
            if c == 1: neg += 1
            if c == 2: pos += 1
        srtuser.append((user,pos,neg,users[user][0]))
    print "Most pos users"
    for user in sorted(srtuser,key=lambda x:x[1],reverse=True)[:10]:
        print " ",user[0],user[1],user[2],[clasis[c].subject_ids for c in user[3]]
    print "Most neg users"
    for user in sorted(srtuser,key=lambda x:x[2],reverse=True)[:10]:
        print " ",user[0],user[1],user[2],user[3]
if __name__ == "__main__":
    main()
